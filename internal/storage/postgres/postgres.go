package postgres

import (
	"context"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/RusGadzhiev/MEPHI-PARVPO/internal/config"
	"github.com/RusGadzhiev/MEPHI-PARVPO/internal/service"
)

var createQuery = `
	CREATE TABLE IF NOT EXISTS concerts (
		concert_id			BIGINT GENERATED BY DEFAULT AS IDENTITY,
		name		    	VARCHAR(1024) NOT NULL UNIQUE,
		places_qty 			INT NOT NULL,
		qty_occupied_places INT NOT NULL,
		sold_out			BOOLEAN,
		PRIMARY KEY(concert_id)
	);

	CREATE TABLE IF NOT EXISTS users (
		user_id			BIGINT GENERATED BY DEFAULT AS IDENTITY,
		name		    VARCHAR(1024) UNIQUE,
		PRIMARY KEY(user_id)
	);

	CREATE TABLE IF NOT EXISTS records (
		record_id		BIGINT GENERATED BY DEFAULT AS IDENTITY,
		user_id		    BIGINT NOT NULL,
		concert_id     	BIGINT NOT NULL,
		PRIMARY KEY(record_id),
		UNIQUE (user_id, concert_id),
		CONSTRAINT fk_user
      		FOREIGN KEY(user_id) 
        		REFERENCES users(user_id)
				ON DELETE CASCADE,
		CONSTRAINT fk_concert
			FOREIGN KEY(concert_id) 
				  REFERENCES concerts(concert_id)
				  ON DELETE CASCADE
	);

	CREATE INDEX IF NOT EXISTS idx_records_concert_id ON records USING hash(
		concert_id
	);

	CREATE OR REPLACE FUNCTION inc(varchar) RETURNS void AS $$
		DECLARE
    		concert ALIAS FOR $1;
		BEGIN
			IF (SELECT places_qty = qty_occupied_places FROM concerts WHERE name = concert) 
			THEN 
				UPDATE concerts SET sold_out = TRUE WHERE name = concert;
			ELSE
				UPDATE concerts SET qty_occupied_places = qty_occupied_places+1 WHERE name = concert;
			END IF;
		END;
		$$ LANGUAGE plpgsql;
`

var insertQuery = `
	INSERT INTO concerts(name, places_qty, qty_occupied_places, sold_out) VALUES(
		'miyagi', 1000, 0, FALSE
	) ON CONFLICT (name) DO NOTHING;
`

var (
	ErrPingPostgres    = errors.New("error of ping postgres")
	ErrNewPoolPostgres = errors.New("error new pool postgres")
)

const (
	Short = "short"
	Long  = "long"
)

type postgresStorage struct {
	pool *pgxpool.Pool
}

func NewPostgresStorage(ctx context.Context, cfg config.PgDb) (*postgresStorage, error) {
	dsn := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s", cfg.User, cfg.Password, cfg.Host, cfg.Port, cfg.Name)

	pool, err := pgxpool.New(ctx, dsn)
	if err != nil {
		return nil, ErrNewPoolPostgres
	}
	if err := pool.Ping(ctx); err != nil {
		return nil, err
	}

	err = prepareDB(ctx, pool)
	if err != nil {
		return nil, fmt.Errorf("db prepare error: %w", err)
	}

	return &postgresStorage{
		pool: pool,
	}, nil
}

func (s *postgresStorage) GetConcert(ctx context.Context, name string) (*service.Concert, error) {
	q := `SELECT name, places_qty, qty_occupied_places, sold_out FROM concerts WHERE name = $1`

	var c service.Concert
	s.pool.QueryRow(ctx, q, name).Scan(&c.Name, &c.PlacesQty, &c.QtyOccupiedPlaces, &c.SoldOut)
	if c.Name == "" {
		return nil, fmt.Errorf("GetConcert error: no such concert")
	}
	return &c, nil
}

func (s *postgresStorage) AddRecord(ctx context.Context, record service.Record) error {

	transaction, err := s.pool.Begin(ctx)
	if err != nil {
		return fmt.Errorf("create transaction error: %w", err)
	}
	defer transaction.Rollback(ctx)

	q := `SELECT "inc"($1);`
	_, err = transaction.Exec(ctx, q, record.Concert)
	if err != nil {
		return fmt.Errorf("update concert transaction error: %w", err)
	}

	q = `INSERT INTO users(name) VALUES ($1) ON CONFLICT (name) DO NOTHING;`
	_, err = transaction.Exec(ctx, q, record.Username)
	if err != nil {
		return fmt.Errorf("insert user transaction error: %w", err)
	}

	q = `
		INSERT INTO records(user_id, concert_id) VALUES(
			(SELECT user_id FROM users WHERE name=$1),
			(SELECT concert_id FROM concerts WHERE name=$2)
		);
		`
	_, err = transaction.Exec(ctx, q, record.Username, record.Concert)
	if err != nil {
		return fmt.Errorf("insert record transaction error: %w", err)
	}

	err = transaction.Commit(ctx)
	if err != nil {
		return fmt.Errorf("commit transaction error: %w", err)
	}

	return nil
}

func (s *postgresStorage) IsRecordExist(ctx context.Context, record service.Record) bool {
	q := `
		SELECT users.name, concerts.name FROM users
		 INNER JOIN records USING(user_id)
		 INNER JOIN concerts USING(concert_id)
		 WHERE concerts.name=$1 AND users.name=$2
		`
		var r service.Record
		s.pool.QueryRow(ctx, q, record.Concert, record.Username).Scan(&r.Username, &r.Concert)
		return r.Username != ""
}

func prepareDB(ctx context.Context, pool *pgxpool.Pool) error {
	_, err := pool.Exec(ctx, createQuery)
	if err != nil {
		return fmt.Errorf("error init postgres (create)")
	}

	_, err = pool.Exec(ctx, insertQuery)
	if err != nil {
		return fmt.Errorf("error init postgres (insert)")
	}
	return nil
}
